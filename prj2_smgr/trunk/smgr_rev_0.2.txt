Описание формата файла версии 0.2

Версия 0.2 полностью наследует правила представления данных, символ разделителя, 
способ представления текстовых и бинарных данных. Отличие от версии 0.1 в 
порядке следования блоков данных и навичие повторяющихся, но пронумерованных блоков
данных.

! - правила те же самые
01) - 0.2 = версия файла
02) - meas_point~XX~ = номер точки измерения
03) - date~YYYY-MM-DD hh:mm:ss = дата и время с точностью до секунды в UTC
04) - microseconds~XXXXXX.X = микросекунды
05) - 8~freq~XXXXXXXX = 8 байтное число = интервал между отcчетами в секундах
06) - 2~max_value~XX = два байта (int16) = максимальное значение амплитуды
07) - ZZZ~sync~XXX....XXX = бинарные данные граффика (int16), ZZZ = количество байт

08) - microseconds~XXXXXX.X = микросекунды начала данного кусочка от начала предыдущего,
                             для нулевого кусочка от начала файла
09) - 8~freq~XXXXXXXX = 8 байтное число = интервал между отчетами в секундах
10) - 2~max_value_a№YYY~XX = два байта (int16) = максимальное значение амплитуды на фазе A
                             для кусочка №YYY. Всегда 3 цифры, начинается с №000 и до №999
11) - 2~max_value_b№YYY~XX = два байта (int16) = максимальное значение амплитуды на фазе B
12) - 2~max_value_c№YYY~XX = два байта (int16) = максимальное значение амплитуды на фазе C
13) - ZZZ~phase_a№YYY~XXX....XXX = бинарные данные граффика (int16) для фазы А, 
                                   ZZZ = количество байт. для кусочка №YYY. Всегда 3 цифры, 
								   начинается с №000 и до №999
14) - ZZZ~phase_b№YYY~XXX....XXX = бинарные данные граффика (int16) для фазы B 
15) - ZZZ~phase_c№YYY~XXX....XXX = бинарные данные граффика (int16) для фазы C 

16) - далее снова с пункта 08 и так до конца файла. 

Что это нам дает?
--------------------------------------------------------------------
Исходный файл, в данном случае, занимал 15.2 Мб 
Просто зажатый в ZIP стал занимать 2.2 Мб
Прореженный таким образом содержит 168 кусочков и занимает 120 Кб
Затем зажатый в архив занимает 41 Кб
В итоге это экономия места более чем в 350 раз. 
Теоретичеески не должно теряться нужной информации
	 
Как это рисовать?
---------------------------------------------------------------------
Пока точных алгоритмов не подскажу, но на ум приходит следующее:
Выводить на график не одномерный массив, в котором точки расположенны регулярно,
а представить это в виде двумерного массива время-значение и на графике 
соединять это линиями. Таким образом объем данных на графике возрастет, но за 
счет того что в пустых местах ничего нет мы вроде должны экономить на памяти.
